
## 심화 과제 2. 우선순위 큐

### `- 개념`   

큐는 먼저 들어오는 데이터가 먼저 나가는 선입선출 (FIFO) 형식의 자료구조지만     
우선순위 큐는 들어오는 순서에 상관 없이 **우선순위가 높은 데이터**가 먼저 나가는 자료구조이다.    
단, 우선순위가 같을 경우에는 큐의 인덱스를 비교해서 더 빠른 순서로 나간다.     

<br>



### `- 저장 방식에 대해`

우선순위 큐를 가능케 하는것이 힙트리(Heap Tree)이다.      
우선순위 큐는 배열, 리스트, 힙트리로 구현할 수 있는데, 이 중 힙트리로 구현하는 것이 가장 효율적이다.     
데이터 저장 방식은 배열&리스트로 하더라도, 힙트리로 구현해 둘 경우 우선순위를 뽑아내기가 가장 쉽기 때문이다.    

<br>



### `- 구조`     

우선순위 큐는 "완전이진트리" 형태의 자료구조를 띈다. (단, 우선순위에 의해 인덱스가 정렬된다.)   

이때, 저장한 데이터의 우선순위를       
데이터가 작은 값일수록 우선순위가 높다고 취급하는 "최소 힙 (min heap)" 케이스와      
데이터가 큰 값일수록 우선순위가 높다고 취급하는 "최대 힙 (max heap)" 케이스가 있다.

최소 힙의 경우, 부모 노드의 값이 자식 노드들보다 작은 구조이고,    
최대 힙의 경우, 부모 노드의 값이 자식 노드들보다 큰 구조이다.     

<br>



### `- 삽입 & 삭제 과정`

- `삽입`    
    > 트리의 최하단 노드에 새로운 값을 삽입한다.     
    > 최하단부터 최상단(루트)까지 트리를 거슬러 올라가면서 Heapify (up-heap) 작업을 수행한다.    
    > --> Heapify이란, 힙의 특성을 만족하도록 각 노드들의 위치를 조정하는 과정이다.    
- `삭제`
    > 최우선 순위인 루트 노드를 삭제한다.    
    > 최하단 노드를 빈 자리(루트)에 가져온다.    
    > 루트부터 최하단까지 내려가면서 Heapify (down-heap) 작업을 수행한다.    

<br>



### `- 구현원리 (의사코드)`    

초기에 생성되는 노드는 루트이므로 인덱스 0을 부여해줌.     

이후에 데이터 추가를 시도할때,      
(예외: 배열이 꽉 찼다면 확장하고, 아니라면)&nbsp; 배열의 끝에 데이터를 추가함.     
배열의 끝에 넣은 데이터가 윗세대의 값들과 비교하며 올라갈지 말지를 결정함. ---> Heapify (up-heap)     
데이터가 들어왔을때 새로 추가한 데이터의 직속 부모 노드와 값을 비교함,     
힙트리가 최대힙일 경우:&nbsp; 현재 노드 < 부모의 노드 일때까지 계속 비교,&nbsp; 부모노드와 값을 바꿈.     
힙트리가 최소힙일 경우:&nbsp; 현재 노드 > 부모의 노드 일때까지 계속 비교,&nbsp; 부모노드와 값을 바꿈.     

이후에 데이터 삭제를 시도할때,      
(예외: 삭제 이후의 배열의 크기가 0이 아닐때에만)&nbsp; 루트 노드의 데이터부터 삭제를 시도함.     
먼저 배열의 끝 데이터를 배열의 0번째로 가져옴 &nbsp;(루트 노드의 값이 사라지므로 루트부터 삭제한 꼴이 됨)     
새로운 루트노드의 값과 자식세대들을 비교하며 내려갈지 말지를 결정함. ---> Heapify (down-heap)     
최대힙:&nbsp; 현재 노드 > 자식노드 (둘중 더 큰 값 ) 일때까지 계속 비교,&nbsp; 부모노드와 값을 바꿈.     
최소힙:&nbsp; 현재 노드 < 자식노드 (둘중 더 작은값) 일때까지 계속 비교,&nbsp; 부모노드와 값을 바꿈.     



> <코드 구현시, 배열로 구성된 힙트리의 인덱스를 표현하는 방법>    
> -- 루트부터 배열의 0번째 인덱스를 부여하고,&nbsp; 다음 노드에 인덱스를 부여하는 순서는 BFS로 탐색 결과임.    
> -- 따라서 n번째 노드의 왼쪽 자식 인덱스 =&nbsp; [(2 * n)+ 1]번째 인덱스이고,    
> -- n번째 노드의 오른쪽 자식 인덱스는 =&nbsp; [(2 * n)+ 2]번째 인덱스이며,    
> -- n번째 노드의 부모 인덱스는 =&nbsp; [(n - 1) / 2]번째 인덱스이다.    

<br>



### `- 사용처`

우선순위 큐는, 우선순위에 따라 최소힙과 최대힙으로 나뉘기 때문에      
(최소/최대힙 중) 어떻게 구현하기를 원하는지에 따라서 오름차순과 내림차순을 전부 구현할 수 있다.   
이러한 이점에 따라 다익스트라 알고리즘을 구현하는 데에도 사용된다고 한다.    

<br>



### `- 본인이 이해한 삽입&삭제과정 (시뮬레이션)`

### - 최대힙의 삽입 과정    
<img src=02_PQ_img_1.png width ="750">

### - 최소힙의 삽입 과정
<img src=02_PQ_img_2.png width ="750">

### - 삭제 과정
<img src=02_PQ_img_3.png width ="750">

<br>
<br>
<br>

----

**▶참고가 된 게시글**    
▷[개념, 삽입&삭제](https://lipcoder.tistory.com/100) &nbsp; ▷[코드구현, 의사코드](https://sam0308.tistory.com/74#:~:text=%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%20%ED%81%90%EB%8A%94%20%EB%82%B4%EB%B6%80%EC%A0%81,%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC%20%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B2%8C%20%EB%90%A9%EB%8B%88%EB%8B%A4.)